# backend/lambda_functions/main.py
from fastapi import FastAPI, HTTPException, Depends, Security
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from fastapi.middleware.cors import CORSMiddleware
from mangum import Mangum
from typing import List, Optional
import os
import json
from datetime import datetime, timedelta
from jose import jwt, JWTError

from services.dynamodb_service import DynamoDBService
from models.expense import Expense, ExpenseCreate, ExpenseUpdate, ExpenseFilter
from models.category import Category, CategoryCreate

app = FastAPI(title="Expense Tracker API", version="1.0.0")

# CORS configuration
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Security
security = HTTPBearer()
db_service = DynamoDBService()

def verify_token(credentials: HTTPAuthorizationCredentials = Security(security)):
    """Verify JWT token from Cognito"""
    token = credentials.credentials
    try:
        # In production, verify with Cognito public keys
        # For now, decode without verification (NOT for production)
        payload = jwt.decode(token, options={"verify_signature": False})
        return payload
    except JWTError:
        raise HTTPException(status_code=403, detail="Invalid authentication token")

def get_current_user(token_data: dict = Depends(verify_token)):
    """Extract user ID from token"""
    user_id = token_data.get('sub') or token_data.get('cognito:username')
    if not user_id:
        raise HTTPException(status_code=403, detail="Invalid user token")
    return user_id

# Expense Endpoints
@app.post("/expenses", response_model=Expense)
async def create_expense(
    expense: ExpenseCreate,
    user_id: str = Depends(get_current_user)
):
    """Create a new expense"""
    expense_data = expense.dict()
    expense_data['date'] = expense_data['date'].isoformat()
    
    try:
        result = db_service.create_expense(user_id, expense_data)
        return result
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))

@app.get("/expenses", response_model=List[Expense])
async def list_expenses(
    category: Optional[str] = None,
    start_date: Optional[str] = None,
    end_date: Optional[str] = None,
    min_amount: Optional[float] = None,
    max_amount: Optional[float] = None,
    year_month: Optional[str] = None,
    user_id: str = Depends(get_current_user)
):
    """List expenses with optional filters"""
    filters = {}
    if category:
        filters['category'] = category
    if start_date:
        filters['start_date'] = start_date
    if end_date:
        filters['end_date'] = end_date
    if min_amount:
        filters['min_amount'] = min_amount
    if max_amount:
        filters['max_amount'] = max_amount
    if year_month:
        filters['year_month'] = year_month
    
    try:
        expenses = db_service.list_expenses(user_id, filters)
        return expenses
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))

@app.get("/expenses/{expense_id}", response_model=Expense)
async def get_expense(
    expense_id: str,
    user_id: str = Depends(get_current_user)
):
    """Get a specific expense"""
    expense = db_service.get_expense(user_id, expense_id)
    if not expense:
        raise HTTPException(status_code=404, detail="Expense not found")
    return expense

@app.put("/expenses/{expense_id}", response_model=Expense)
async def update_expense(
    expense_id: str,
    expense_update: ExpenseUpdate,
    user_id: str = Depends(get_current_user)
):
    """Update an expense"""
    updates = expense_update.dict(exclude_unset=True)
    if 'date' in updates and updates['date']:
        updates['date'] = updates['date'].isoformat()
    
    try:
        result = db_service.update_expense(user_id, expense_id, updates)
        return result
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))

@app.delete("/expenses/{expense_id}")
async def delete_expense(
    expense_id: str,
    user_id: str = Depends(get_current_user)
):
    """Delete an expense"""
    try:
        db_service.delete_expense(user_id, expense_id)
        return {"message": "Expense deleted successfully"}
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))

# Category Endpoints
@app.post("/categories", response_model=Category)
async def create_category(
    category: CategoryCreate,
    user_id: str = Depends(get_current_user)
):
    """Create a new category"""
    try:
        result = db_service.create_category(user_id, category.dict())
        return result
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))

@app.get("/categories", response_model=List[Category])
async def list_categories(user_id: str = Depends(get_current_user)):
    """List all categories"""
    try:
        categories = db_service.list_categories(user_id)
        return categories
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))

# Lambda handler
handler = Mangum(app)
